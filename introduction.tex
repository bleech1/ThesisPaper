\chapter{Introduction}
\label{sec:intro}

Many modern applications split functionality into multiple processes, allowing programmers to achieve the design principle of separation of concerns.  For example, by creating a password manager that uses two processes, one to store the passwords and a second to display them to the user, programmers can focus on the two very different tasks.  One group can ensure that the stored passwords are unable to be stolen from the machine, while the other can provide the interface between the user and his or her information.  This also allows someone with security expertise to only work on keeping the passwords safe and a user-interface designer to create a functional UI, instead of having one group work in areas that are not their strengths.  However, separating related operations into different processes implies that they must communicate in some way.  The password manager needs some way of getting the passwords from the secured database to the UI for the user to view.  This is an example of inter-process communication.

\section{Inter-Process Communication}
\label{sec:ipcIntro}
Inter-process communication is any form of communication between running processes.  This is a very broad definition that applies to much of the way that we use computers.  Inter-process communication, or IPC, captures everything from email to using a web browser to get webpages from a web server to password managers transmitting passwords within a computer.  Local IPC is communication that occurs within a single computer.  Instead of traversing the internet and interacting with many hosts, local inter-process communication stays completely inside one computer, and is often dealt with entirely by the kernel.  Inter-process communication and local IPC will be further explored in Chapter~\ref{sec:interProcessCommunication} Section~\ref{sec:formsOfLocalIPC}.

\section{Insecurity of Inter-Process Communication}
\label{sec:ipcInsecurity}
\subsection{What does it mean to be insecure?}
\label{sec:whatIsInsecure}
For an application to be insecure, an attacker must be able to exploit the application to act in a way that is not desired.  These attacks can be broken down into two broad classes: information disclosure and execution hijacking.  An information disclosure attack is when an attacker gains access to victims' confidential information.  This can include passwords, social security numbers, bank credentials, or other private information.  These attacks have been in the news recently as large companies like social media giant Facebook~\cite{o'sullivan_2018} and credit agency Equifax~\cite{timberg_dwoskin_fung_2017} have been hacked and millions of users' private information was taken.  

Execution hijacking attacks occur when an attacker is able to run arbitrary code on a victim's machine.  If the attacker can run code as the victim, then he or she can act while pretending to be the victim.  To an outside viewer, seeing a program running as a user on that user's computer would be expected, so attackers would be able to impersonate the victim without being easily spotted as a hacked machine.  These attacks violate a victim's security and privacy by allowing hackers to steal confidential information and use a victim's identity to perform arbitrary actions.  These two classes of attacks, while different, are similar in their lasting effects.  Attackers are able to act as the victim and do what they would like.  Whether that means using a stolen social security number to open a new credit card account or running a process on a victim's computer to send spam emails, the attacker gains new opportunities to act with the direct consequences falling onto the victim.

\subsection{Security of Networked IPC}
\label{sec:networkedIPCSecurity}
Since it requires other computers to handle a user's data, networked inter-process communication is fundamentally insecure.  Any computer on the route between the source and destination is given the data, and in theory, could do whatever it wants with the data.  This could include storing the data and attempting to decrypt the data offline, or monitoring the traffic that different hosts and users send.  Without encryption, any computer along the path between the source and destination computers would be able to read all information passed in the message, allowing information disclosure vulnerabilities to be trivial.  This would include passwords, credit card numbers, and other forms of private information that are constantly sent through the internet.  To protect against this, much of the confidential information sent across the internet is encrypted.  As the internet has become more popular, more and more information is being encrypted when sent over the network.  In the past, HTTPS, the encrypted version of HTTP, was used for secure transactions only, such as entering a credit card number to make an online purchase or typing in a password to log into an account.  However, HTTPS is used more than ever before~\cite{google_transparency_report}.  This allows users to protect their browsing history and helps to reduce the ability of attackers to forge website URLs through the use of certificates.  However, even with this and other precautions, anytime that personal or confidential information is sent through other machines, that communication should be considered insecure.

\subsection{Security of Local IPC}
\label{sec:localIPCSecurity}
Local IPC, on the other hand, is completely contained within a single computer.  The messages stay within the machine, and are almost always handled by the kernel itself.  However, that does not mean that this communication is completely secure.  In fact, since many believe that communicating within a single computer is secure, security precautions that are standard for networked communication are often missing in local IPC~\cite{MitMa}.  It is not the case that programmers do not try at all to secure this communication; in fact, there is often some form of security, but it is not enough, as shown by~\cite{MitMa}.  These researchers studied the ways that applications communicate locally and were able to impersonate the client or server, or both, in a dozen commonly-used applications.  Further, they showed that it is possible to do so while also making it difficult for the victim to know that their machine has been compromised.  Using the `nohup' command on Macs and Linux and fast-user switching on Windows, users are able to keep programs running even after they have logged off.  Most personal computers have only one personal account, but many users do not turn off the guest account.  Using this guest account, an attacker could start a malicious program and log off.  The victim would only know that his or her computer was compromised if he or she were to look through all of the currently running processes.  An even more fertile ground for this attack is a public terminal.  Many institutions such as libraries and universities have computers with many accounts on them.  For example, at Middlebury College, every member of the faculty and staff, as well as each student, has an account.  Therefore, each of these people is able to log onto the many public computers that the College makes available.  By targeting these public terminals, an attacker would be able to gain access to the confidential information of many different users, instead of only one at a time on a personal computer.


\section{Plan of this thesis}
\label{sec:planOfThesis}
Since we know that local IPC is of concern, it would be helpful to characterize the security of individual applications that use this form of communication.  Therefor, I first created a survey to see what commonly-used applications run on people's computers and what is each application's local IPC footprint.  After gathering these results, I found the applications that are most used, as well as which applications used the most of each of the three forms of local IPC that I am investigating: communication over localhost, UNIX domain sockets, and named pipes.  This way, I looked at applications that are used everyday by many people and which use different forms of local IPC.  I chose to look at APPLICATION1, APPLICATION2, and APPLICATION3 because of REASON1 and REASON2.  Then, I took a two-pronged approach to investigate their security.  First, I studied the communication between processes to see if it would be possible to send phony messages and hijack execution or access confidential information due to lax security procedures.  Secondly, I used fuzzing software, discussed further in Section~\ref{sec:fuzzing}, to find cases where a process does not correctly parse its input.  If a fuzzer's input could cause a crash in the process, then that would signal a bug that could possibly be exploited.


\section{Related Work}
\label{sec:relatedWork}
\subsection{Man in the Machine Attacks}
\label{sec:manInMachineAttack}
In a 2018 paper, Bui et al. looked at the forms of local IPC used by common applications and found that they were able to read communication between processes and either hijack execution or disclose confidential information~\cite{MitMa}.  They named this attack the Man in the Machine Attack, since the attacker is using communication that stays within the computer.

These authors explored the situation where an attacker had access to the victim's host, but neither as an administrator nor as the victim.  Instead, the attacker used a separate login session, either as another authenticated user to that computer, or using the guest account.  Many people who use a personal computer do not disable the guest account, which leaves their computer open to possible attacks.  Additionally, a public terminal with many accounts, such as at a university or an office, would allow an authenticated user to possibly steal confidential information from many people, instead of the single victim of a personal computer.  Using fast user switching on Windows~\cite{microsoft_developers_network_2018} or running a program with `nohup' on MacOS and Linux allows a program to run even when the user who started the program is no longer logged in, or the user is running in the background.  Using these techniques, an attacker could start the malicious program while logged into an account, then log out while continuing their attack.

Bui et al. looked specifically at three vulnerable types of local IPC: network sockets, Windows named pipes, and universal serial bus (USB) security tokens.  Network sockets provide an easy attack vector for both client and server impersonation.  Since the authors only investigated local IPC, the IP address for all communication was the localhost address, 127.0.0.1.  Therefore, they only needed to find what port the software used to find the communication between the processes.  A server listens on a set of specific port numbers that is defined in the source code, so a malicious process would need to connect to one of these ports to impersonate a client.  If the server can only support one connection, then the malicious client must connect before the genuine client does.  To impersonate the server, the malicious program must listen on the selected ports before the actual server has the chance to bind to them.  By creating a fake client and then a fake server, an attacker is able to complete a man-in-the-middle attack.

Using named pipes, it is similarly easy to impersonte the actual named pipe.  Instead of using port numbers, named pipes have a name, or location in the filesystem, that can be used to identify them.  To impersonate the client, the malicious program must join the named pipe as a reader, and to impersonate the server, the program must create the named pipe before the real server does.  The only requirement for either of these is to know the name of the pipe, which can easily be found by running the `lsof' program on UNIX operating systems or the `handle' or `pipelist' programs on Windows~\cite{russinovich_2018}~\cite{markruss_sharkey_2016}.  The attacker can then use this name for his or her attack.

The last class of vulnerable local IPC is USB security tokens.  A USB device is available to any user once it is plugged into the machine, so the programmers behind the software on the USB must implement security features to protect unwanted use of the device.  Without these features, any user, including the malicious user, could access the USB token.

Bui et al. also found that there are some types of local IPC that are immune to the man in the machine attack.  The two most common types are anonymous pipes and anonymous socket pairs.  Anonymous pipes are often used in pipelines while using a shell.  A command like `ls $|$ grep *sys*' uses an anonymous pipe to take the output of `ls' and send it as input to `grep'.  These pipes are safe while named pipes are not because the anonymous pipe is created by one process, so it owns both ends of the communication channel.  The pipe also does not have a name that can be joined by other processes.  Therefore, for another process to have access, it must be given one end.  This mostly occurs between parent and child processes, as in the shell example above.  Socket pairs are safe for the same reason.  Since the sockets do not have names and cannot be joined by outside processes, any process that uses them is considered safe because it must be explicitly granted access by the process that owns the sockets.

The authors went on to study four classes of applications: password managers, USB hardware tokens, applications that have an HTTP backend, and two other applications of interest.  Of the thirteen applications studied, twelve were vulnerable to some form of impersonation, while the last was vulnerable to signing incorrect two-factor authentication requests.

Some of the studied password managers had such careless security that a man in the machine attack was trivial.  RoboForm connected its browser extension with the password database through localhost, and communicated the password in plaintext.  To steal a user's passwords, the attacker only needed to connect to port 54512 on localhost, ask for a list of accounts, and then choose one of the keys that was sent from the database.  The database would then send the password associated with that account in plaintext.  While the other password managers had stricter security, Bui et al. were able to impersonate one side of the conversation because of weak key-exchange protocols, secret keys stored in Javascript code, or other easily fixable security holes.

The two applications that used hardware tokens are used for two-factor security.  While the password is the ``thing you know,'' a physical two-factor device is a ``thing you have.''  Two-factor authentication with a security token is employed when a user wants extra security for an account by requiring both a ``thing you know'' and a ``thing you have.''  For example, one of the studied tokens, Fujitsu DigiSign, is used by the Finnish people to interact with government services, including healthcare resources~\cite{MitMa}.  The attack on this token takes the primary port that the card-reader listens on before the real client can, then impersonates the server by connecting to the real client from a secondary port.  This allows the attacker to have malicious requests signed by the token and the user.

The other applications, while lacking the security that is required of a password manager or security token, still have insufficient security.  For example, Spotify is a music streaming platform that uses a localhost socket to play music.  After connecting to the server, an attacker can spoof the Origin field in the header of the HTTP request so the malicious request will be accepted by the server.  They could then design the payload of the packet to change the song that the victim is listening to.  MySQL is a database server that can be configured to use named pipes.  Here, an attacker can join the server's real named pipe as a reader and create its own instance for the client to join, resulting in a man in the middle attack.  The attacker can then query the database itself, as well as modify legitimate queries to and responses from the database.

\subsection{Local IPC Vulnerabilities}
\label{localIPCVulnerabilities}
Bui et al. were not the first to identify vulnerabilities in local IPC.  Many have found issues with the way local IPC is implemented by kernels.  Named pipes, specifically in Windows, have well-documented security issues.  First of all, the default access rights for a Windows named pipe allow anyone to read it, meaning that a programmer must change the default to securely use a named pipe~\cite{microsoft_2018}.  Additionally, a lack of complete understanding of how to use named pipes created many vulnerabilities in Windows applications that gratuitously used named pipes, including a remote code execution attack against qBittorrent~\cite{cohen_2019}.  Additionally, by exploiting the way that Windows creates named pipes, a named pipe writer could gain the security context of and impersonate the reader~\cite{watts2002discovering}.

However, named pipes are not the only form of local IPC with vulnerabilities.  It has been shown that apps on both iOS and Mac OS X can use IPC to gain access to all the resources of a victim app~\cite{Xing_2015_CAI_2810103_2813609}.  A malicious app was able to bind to the port used by the 1Password password manager before the real app could.  Then, the attacker could steal passwords, even though the two apps were supposed to be sandboxed from each other.  On the Android operating system, UNIX domain sockets have been shown to be vulnerable as well.  A malicious program could give itself root access, view the confidential files of other apps, or access the Bluedroid (Android Bluetooth) radio and control devices connected through Bluedroid~\cite{Shao_2016_MAU_2976749_2978297}.  These vulnerabilites are due to a lack of authentication by both processes connecting to the socket.