\chapter{Discussion}
\label{sec:discussion}
In the course of my research, I have found ways for developers to create secure software, as well as practices that can produce security problems.  By looking at these four applications---Spotify, VS Code, launchd, and mDNSResponder---I identified three possible attacks.  First, there is a bug in either the VIM extension of VS Code or VS Code itelf when parsing incoming TCP data.  I was able to crash the VIM extension by fuzzing this socket with a bogus HTTP GET request.  This bug could be a vulnerability that could be exploitable.

I also found two Denial-of-Service attacks, one each against VS Code and mDNSResponder.  In VS Code, I could create the main UNIX domain socket before running the application, and therefore the actual VS Code instance would not start.  For mDNSResponder, I removed its named UNIX domain socket and remade it myself, which essentially made applications that need Internet access unusable.  These last two vulnerabilities are similar to those found by Bui et. al. in their Man-in-the-Machine paper, which found client or server impersonation attacks in many different applications~\cite{MitMa}.

I expanded their research by also looking at UNIX domain sockets and found interesting security holes, described above, as well as ways that these can contribute to secure systems.  As noted before, \texttt{socketpair} UNIX domain sockets are more secure than the other forms of local IPC that I investigated because it is impossible to join them from an outside process.  A process must be explicitly given access to send or receive data over one of the sockets, creating much stricter access control than any other form of local IPC that I investigated.

In addition to the \texttt{socketpair} UNIX sockets, some applications improve their security by closing a socket whenever it has received the maximum number of messages that it expects.  For example, the named USB UNIX domain socket owned by launchd would close any connection after receiving a single message.  I believe that this was done to prevent possible fuzzing attacks and other input-based attacks.

These vulnerabilities could be solved by following a few common-sense fixes.  For example, an application should randomize the name of a named UNIX domain socket or named pipe, so that a malicious process cannot impersonate it before the application starts.  If a resource must have a predictable name, then applications must check the return value of calling \texttt{bind} to ensure that the bind has succeeded and that there is not already an instance of that named object.

Another solution is to think about the complexity of the input language that a process should accept when designing the communication protocol.  Developers need to consider if it is possible to prove that a parser accepts exactly the desired input language.  If it is not possible, then the protocol needs to be redesigned so that it can be.  This will help reduce the prevalence of input-based attacks.

Finally, software developers need to follow the same best-practices used for Internet communication for local IPC.  This includes encrypting every message and confirming the identity of the remote end of a communication channel.  This way, the security of local IPC will not be lagging behind networked IPC as it is today.

As time goes on, applications will become more secure as better practices are created and adopted.  However, as my thesis shows, time is not the only solution to creating safe and secure software.  We as developers need to think about ways to prove that our software is secure before we design it, not after.  We must never assume that we have found all of the possible bugs in our software and must continue to test continuously and rigorously.  These practices will create a safer virtual world to live in.
