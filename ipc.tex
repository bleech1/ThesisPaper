\chapter{Inter-Process Communication}
\label{sec:interProcessCommunication}

Inter-process communication (IPC) is the way that any two processes communicate with each other.  Anytime that two processes need to comunicate, they use IPC.  This can include different applications, such as a web server sending pages to a web browser, or separate processes of the same application, such as Spotify and Spotify Helper working together to play music.  When this communication occurs within one computer, it is local IPC.


\section{Benefits of IPC}
\label{sec:benefitsOfIPC}
There are many problems that are well-solved by having a multi-process application.  These are normally problems that have multiple distinct functions, since each task can be separated into its own process.  Examples of applications that fall into this category would be web servers, password managers, and XWindows.

WEB SERVERS DISCUSSION - NEED SOURCES FOR THIS

Password managers also make use of multiple processes to separate the jobs of storing passwords securely and entering the password into forms.  A password manager may have three processes running at all times.  One process encrypts and secures the passwords on disk, ensuring that no malicious user can access the plaintext of the passwords.  Some of these processes go so far as to create fake sets of passwords, so that an attacker would not know which set of encrypted passwords is real~\cite{bojinov2010kamouflage}.  A second running process could be an app on the computer so that a user can read or edit the password, and a third process could be a browser extension to autofill passwords into webpages.  Both of these processes need to communicate with the password storage process so that they can receive the passwords.  The browser extension needs the plaintext of the password before it can put it into the webform, as does the desktop app before it can display the password to the user.  The communication occurs via local IPC, since all three processes would run on a single host.

Password managers lend themselves to having multiple processes because all three processes solve different jobs.  The password vault needs to keep the passwords encrypted and secure from outside access, but needs to provide the password when either of the other two processes legitimately requests it.  The desktop app should provide an easy-to-use user interface so that the user can edit or view the desired password.  Finally, the browser extension needs to find password fields in online forms and automatically fill them with the correct password based on the URL of the webpage.  By splitting each task into its own process, each process can be optimized for its use.  As long as the passwords can be communicated between the processes, they will be able to work together and function as a successful password manager.

XWindows is another application that benefits from using multiple processes.  XWindows is a program that displays the graphics on a monitor.  It uses two processes, a client and a server, to create and present the images.  The server process takes in input from the mouse, keyboard, and other peripherals and sends it to the correct client, while also receiving information from the clients about what should be displayed~\cite{Scheifler:1986:XWS:22949.24053}.  Each client process is a different application which takes in mouse and keyboard data, does computation using this and the current state of the application, and sends to the server what it would like shown on the screen~\cite{Scheifler:1986:XWS:22949.24053}.  Using this model, one server can have many clients connected to it.  This allows a single screen to display multiple applications at the same time, since each application has its own client.  Also, this means that the server can demultiplex incoming signals from the mouse and keyboard and send them to the correct client.  This architecture also allows a single application to be displayed on multiple screens, since a client can connect to multiple servers.  XWindows would almost certainly be unable to achieve the same benefits if it was a single-process application.  The benefits gained from using multiple processes cannot be replicated with a single process.

\section{Local IPC Background}
\label{sec:localIPCBackground}
Local IPC is inter-process communication that occurs entirely within a single computer.  Both password managers and XWindows, described above, utilize local IPC often.  Many password managers exist completely within one computer, so they only communicate the passwords within that host.  The XWindows client and server are often run within a computer as well.  In these scenarios, they use local IPC to efficiently communicate and work together.  Local IPC also has the benefit of avoiding some of the overhead required for networked communication since it is guaranteed to stay within the computer.  This can make local IPC significantly faster than networked communication.  The tradeoffs of using different forms of local IPC will be discussed further in Section~\ref{sec:formsOfLocalIPC}.

Since local IPC never leaves the host, the security implications of the communication are less clear than networked IPC.  With networked communication, the messages go through other people's computers, making the communication intrinsically insecure.  However, since local IPC is contained to one computer, some security expers believe it is not worth trying to encrypt this communication and keep it secure.  They believe that if an attacker has access to the host, which would be required to exploit an application that only uses local IPC, then he or she already has full access to the computer, so any effort to encrypt or keep information secure is futile.  Section~\ref{sec:hostOnlyAttackVectors} has more context about host-only attack vectors.  As shown by~\cite{MitMa}, many applications do make some effort to encrypt local IPC, but not to the same extent as their networked communication.  They use defective key-exchange protocols or lack two-way authentication to confirm the other party they are talking with.

\section{Forms of Local IPC}
\label{sec:formsOfLocalIPC}
This thesis studies three forms of local IPC: communication through localhost, UNIX domain sockets, and named pipes.  We will discuss each in more detail here.

\subsection{Localhost}
\label{sec:localhost}
Localhost, also known as the loopback interface, is an interface provided by computers to communicate with itself.  This interface can be used to replicate the complete network stack, and is especially useful when testing networked applications without a working internet connection.  However, this interface is also used for local inter-process communication.  One of the benefits of using localhost for local IPC is that the entire infrastructure used for networked communication can stay the same.  The only change that needs to be made is to use the IP address of localhost, 127.0.0.1, instead of the IP address of another interface.

When communicating over localhost, a message is sent using the entire network protocol stack, including the link, network, and transport layers.  Each layer contains a header, which provides metadata about that layer, and data, which can be any assortment of bits.  For example, IP is a protocol in the network layer, so sits in between the link and transport layers.  An IP packet has a header that contains the source and destination IP address, a checksum, and a field that describes the type of information contained in the data section.  Then, in the data section, an entire TCP or UDP packet would be contained, which would hold the TCP or UDP header, as well as the data inside of that layer.  This process is called encapsulation, since each higher layer is encapsulated as data within the next outer layer.

The link layer is used to differentiate which computer on a physical wire should accept incoming frames.  A normal ethernet frame contains the source and destination MAC addresses, each six bytes long, as well as two bytes to indicate the network layer being used.  However, when using localhost, this can be optimized, since only one computer, the current host, is on the ``wire'' and it should listen to all incoming connections to localhost.  Therefore, when using localhost, the entire link layer header is four bytes that determine the family of network layer.  Most of the time, this will be IP, which has the family value of 2.

The network layer used when communicating over localhost is the same as is used for networked IPC.  This layer is predominantly IP.  The IP header contains information about what interface the packet is destined for, as well as what type of data is contained inside~\cite{RFC0791}.  While the ethernet layer can be condensed when communicating through the loopback interface, the IP layer cannot, because the kernel needs to know what interface to send the packet to, which is represented in this layer.  The kernel has to route the packet to the code to encapsulate the IP packet as either an ethernet or localhost frame, so must be able to know the destination IP address.

The last layer commonly used in the network protocol stack is the transport layer.  This layer contains port numbers to identify the source and destination process, as well as sequence numbers to guarantee delivery of messages, if the transport layer is TCP~\cite{RFC0793}.  The common transport layer protocols are TCP, which sends a stream of data, and UDP, which sends individual frames, called datagrams.  TCP also adds a guarantee of delivery and in-order delivery, which UDP and the network layer protocols do not have.  Like the network layer, this layer is needed because the kernel needs to know, for both ends of the communication, what process to give the packet to.

Inside of the transport layer is the application layer.  This can be a popular protocol like HTTP or the bit torrent protocol, or it can be a proprietary protocol.  Many applications have their own application layer protocol to transmit the exact information that is needed, along with the desired amount of security.

When a process uses the loopback interface to communicate with another process, it uses this entire protocol stack: the condensed link layer, the network layer, and the transport layer.  This can be very useful for a programmer, since from a programming perspective, the code is the exact same as the code for networked communication, except for the destination IP address.  There is no need to use different data structures or macro values, since the communication almost completely mocks real internet communication.  Also, if there is a possibility that the communication endpoint will change from localhost, it is very easy to modify the code since only the address would be changed.

\subsection{UNIX Domain Sockets}
\label{sec:unixDomainSockets}
If the programmer knows that the communication will never leave the computer, then he or she may decide that the overhead of the entire network stack is not necessary.  Therefore, the programmer could instead use UNIX domain sockets, a form of local IPC that works similarly to internet sockets.  Like internet sockets, UNIX domain sockets, also known as UNIX sockets or IPC sockets, create a bidirectional channel of communication.  These sockets can be created to send a stream like TCP, datagrams like UDP, or can be a raw socket.  However, raw sockets are almost never used~\cite[229--230]{Stevens:1996:TIT:233130}.  While internet sockets use an IP address and port number as the namespace to find and send packets, UNIX domain sockets use the filesystem as the namespace~\cite[231]{Stevens:1996:TIT:233130}.  However, while the namespace is different, the same commands are used to create, write to, and read from both internet and UNIX domain sockets.

In addition to the lower overhead than internet sockets, UNIX domain sockets have two additional benefits that no other form of IPC can replicate.  UNIX domain sockets are able to send file descriptors and credentials to the connected socket~\cite[381--394]{Stevens:1997:UNP:522800}.  By being able to send file descriptors, UNIX domain sockets provide a way for processes to share file descriptors outside of fork and exec.  Additionally, this is allowed for any type of descriptor, so processes can send pipe, socket, or file descriptors through a UNIX domain socket.  Once the descriptor is sent, the receiver will be able to open it whenever it chooses, even if the sender closes the descriptor before the receiver opens it.  The other unique benefit of UNIX domain sockets is their ability to pass credentials through the socket as well.  This can be used as a security check by a server process to guarantee that a client is allowed to request the service to be done.  This is the only way to guarantee that a process is receiving the genuine credentials of a client.

To send data across a UNIX domain socket requires many fewer steps than to send data via an internet socket.  To send data over a datagram UNIX domain socket, the sockets are first connected using the destination pathname given.  To send the data, control information, if given, along with the sender's address and the data itself are placed at the back of the receiver's receive queue by the kernel and processes waiting to read from the recieving socket are woken up~\cite[263--265]{Stevens:1996:TIT:233130}.  Control information would contain descriptors or credentials that are passed through the socket.  The sender's address is not necessarily required, although the receiver will not be able to reply is the sender does not include its address; this can be ok in circumstances when the sender does not need a reply.  Finally, the data is the bytes that the sender actually wants to send.

Just like with a datagram UNIX socket, sending a stream of data with a UNIX socket is much easier than over an internet socket.  To send a stream of data, the kernel connects the two sockets if they are not already connected, then the data is moved to the receiver's receive queue~\cite[265--268]{Stevens:1996:TIT:233130}.  Any readers that are waiting for input on that socket are then woken up to read the incoming data, and the reader updates the size of the sender's and reciever's queues to reflect that the data has been read.  The kernel is able to move the data directly from the sending process to the receiving process with just the required permission checks.

\subsection{Named Pipes}
\label{sec:namedPipes}
Sockets that use the loopback interface and UNIX domain sockets provide bidirectional communication channels, but that is not always necessary.  If only a unidirectional channel is required, then processes can open a named pipe.  A named pipe, or FIFO, is a special type of file that lets a process send data to another process.  Named pipes use the filesystem as their namespace.  A pipe's `name' is given when it is created, and this is used when another process wants to connect to the pipe.  Once a pipe exists in the filesystem, any process that knows, or guesses, the name of the pipe can open one end, either as a reader or as a writer.  Using a named pipe looks as if the named pipe is a normal file and is being written to and read from using output and input redirection.  However, a named pipe is more efficient than storing the data in a temporary file since the kernel can buffer it instead of writing it to disk.

Named pipes are different than anonymous pipes, since they are able to be joined as long as a process knows the name.  However, anonymous pipes, like those used in pipelines in a shell, have much stricter access controls.  When an anonymous pipe is created, only the process that created it can gain access to it.  Often, this process will fork and exec soon after, which allows the child process to have access to the pipe as well.  In this sense, a process must be explicitly given access to an anonymous pipe, either through UNIX domain socket descriptor passing or as a child to a process with the pipe open.  This is very different from named pipes where any process is able to open either end.

\section{Tradeoffs Between Forms of Local IPC}
\label{sec:localIPCTradeoffs}
When deciding what form of local IPC to use, all three of these types: using the loopback interface, UNIX domain sockets, and named pipes, provide benefits that should be considered by application programmers.  By using the full network stack and the loopback interface, programmers can use the exact same commands and arguments that they are used to using from creating networked communication.  The only difference is that the destination IP address will always be the loopback interface.  If they decide to use localhost, they then must decide whether to use TCP or UDP in the transport layer.  TCP requires more overhead, such as the three-step-handshake to create the connection, but guarantees delivery and in-order delivery.  However, a programmer may be confident that packets will very rarely be lost by the kernel, since they never leave the host, and could want the lower cost of UDP.

However, if the overhead of the network stack is too high for a specific application, a programmer could use UNIX domain sockets.  UNIX domain sockets avoid almost all of the network stack, and the kernel transmits the data directly from the sender to the receiver.  In fact, on four different Berkeley-derived systems, UNIX domain sockets were over twice as fast as TCP sockets that used the loopback interface~\cite[223--224]{Stevens:1997:UNP:522800}.  XWindows takes advange of this speed boost when it starts up by seeing if the server and client are on the same host, and if they are, creates a UNIX socket instead of an internet socket.  UNIX domain sockets also have the ability to pass file descriptors and user credentials, giving other processes access to objects they previously could not access and giving them a way to guarantee that they are receiving genuine credentials.

UNIX domain sockets also can be created using the socketpair system call, which creates both endpoints and gives both endpoints to the creating process.  This is similar to a process creating an anonymous pipe, since no other process has access to read from or write to the socket, unless it is explicitly given access by being sent a descriptor or through a fork.  This process is so similar to creating a pipe, that anonymous pipes are often actually made by the socketpair system call, then one end is made read-only and the other is made write-only~\cite[253]{Stevens:1996:TIT:233130}.

Named pipes have a similar advantage to UNIX domain sockets where their namespace is the filesystem, so any process that knows their name can join as a reader or writer.  They also provide a unidirectional data channel if that is desired by the application architecture.  Named pipes do not have any inherent security, so programmers must be careful that a named pipe that they create is the first instance.

All of these forms of local IPC, except for UNIX sockets created by the socketpair command, must use some form of authentication to ensure the other end of the communication is the correct program.  Any program is able to read or write to an internet socket, UNIX domain socket, or named pipe, so security measures need to be put in place by the application.

To decide the right choice of local IPC, programmers need to know how their application will be transferring data.  As shown in~\cite{Xiurong2011TheAA}, the size of writes can affect the speed of transmission.  Therefore, depending on the size of data sent at a time, different forms of local IPC may be preferable.  Based on~\cite{immich2003performance} and ~\cite{Stevens:1997:UNP:522800}, we can conclude that of the three forms of local IPC studied, named pipes are the fastest, followed by UNIX domain sockets, followed by sockets that send over localhost.  These speed differences are significant, but other factors contribute to the decision of which form of local IPC should be used.
